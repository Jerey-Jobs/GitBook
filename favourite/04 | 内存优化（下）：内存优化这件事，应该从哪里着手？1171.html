<div class="_2c4hPkl9"><div data-slate-editor="true" data-key="966" autocorrect="off" spellcheck="false" data-gramm="false" style="outline: none; white-space: pre-wrap; overflow-wrap: break-word;"><div class="se-7865400b" data-slate-type="paragraph" data-slate-object="block" data-key="967"><span data-slate-object="text" data-key="968"><span data-slate-leaf="true" data-offset-key="968:0" data-first-offset="true"><span data-slate-string="true" class="">在掌握内存相关的背景知识后，下一步你肯定想着手开始优化内存的问题了。不过在真正开始做内存优化之前，需要先评估内存对应用性能的影响，我们可以通过崩溃中“异常退出” 和 OOM 的比例进行评估。另一方面，低内存设备更容易出现内存不足引起的异常和卡顿，我们也可以通过查看应用中用户的手机内存在 2GB 以下所占的比例来评估。</span></span></span></div><div class="se-bfc6f8cc " data-slate-type="paragraph" data-slate-object="block" data-key="969"><span data-slate-object="text" data-key="970"><span data-slate-leaf="true" data-offset-key="970:0" data-first-offset="true"><span data-slate-string="true">所以在优化前要先定好自己的目标，这一点非常关键。比如针对 512MB 的设备和针对 2GB 以上的设备，完全是两种不同的优化思路。如果我们面向东南亚、非洲用户，那对内存优化的标准就要变得更苛刻一些。</span></span></span></div><div class="se-65bbfb0c " data-slate-type="paragraph" data-slate-object="block" data-key="971"><span data-slate-object="text" data-key="972"><span data-slate-leaf="true" data-offset-key="972:0" data-first-offset="true"><span data-slate-string="true">铺垫了这么多，下面我们就来看看内存优化都有哪些方法吧。</span></span></span></div><h2 class="se-d234c04c" data-slate-type="heading" data-slate-object="block" data-key="973"><span data-slate-object="text" data-key="974"><span data-slate-leaf="true" data-offset-key="974:0" data-first-offset="true"><span data-slate-string="true">内存优化探讨</span></span></span></h2><div class="se-cc0e6507 " data-slate-type="paragraph" data-slate-object="block" data-key="975"><span data-slate-object="text" data-key="976"><span data-slate-leaf="true" data-offset-key="976:0" data-first-offset="true"><span data-slate-string="true">那要进行内存优化，应该从哪里着手呢？我通常会从设备分级、Bitmap 优化和内存泄漏这三个方面入手。</span></span></span></div><div class="se-bf142fa1 " data-slate-type="paragraph" data-slate-object="block" data-key="977"><span data-slate-object="text" data-key="978"><span data-slate-leaf="true" data-offset-key="978:0" data-first-offset="true"><span class="se-dc69f735" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">1. 设备分级</span></span></span></span></div><div class="se-48bfe3bb " data-slate-type="paragraph" data-slate-object="block" data-key="979"><span data-slate-object="text" data-key="980"><span data-slate-leaf="true" data-offset-key="980:0" data-first-offset="true"><span data-slate-string="true">相信你肯定遇到过，同一个应用在 4GB 内存的手机运行得非常流畅，但在 1GB 内存的手机就不一定可以做到，而且在系统空闲和繁忙的时候表现也不太一样。</span></span></span></div><div class="se-b67af75c " data-slate-type="paragraph" data-slate-object="block" data-key="981"><span data-slate-object="text" data-key="982"><span data-slate-leaf="true" data-offset-key="982:0" data-first-offset="true"><span class="se-d24b7e9d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">内存优化首先需要根据设备环境来综合考虑</span></span></span></span><span data-slate-object="text" data-key="983"><span data-slate-leaf="true" data-offset-key="983:0" data-first-offset="true"><span data-slate-string="true">，专栏上一期我提到过很多同学陷入的一个误区：“内存占用越少越好”。其实我们可以让高端设备使用更多的内存，做到针对设备性能的好坏使用不同的内存分配和回收策略。</span></span></span></div><div class="se-1e95a01b " data-slate-type="paragraph" data-slate-object="block" data-key="984"><span data-slate-object="text" data-key="985"><span data-slate-leaf="true" data-offset-key="985:0" data-first-offset="true"><span data-slate-string="true">当然这需要有一个良好的架构设计支撑，在架构设计时需要做到以下几点。</span></span></span></div><div class="se-77dc64d6" data-slate-type="list" data-slate-object="block" data-key="986"><div class="se-830e1980 se-2f792f39" data-slate-type="list-line" data-slate-object="block" data-key="987"><span data-slate-object="text" data-key="988"><span data-slate-leaf="true" data-offset-key="988:0" data-first-offset="true"><span data-slate-string="true">设备分级。使用类似 device-year-class 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能；使用 565 格式的图片，使用更小的缓存内存等。在现实环境下，不是每个用户的设备都跟我们的测试机一样高端，在开发过程我们要学会思考功能要不要对低端机开启、在系统资源吃紧的时候能不能做降级。</span></span></span></div></div><div class="se-31e78167 " data-slate-type="paragraph" data-slate-object="block" data-key="989"><span data-slate-object="text" data-key="990"><span data-slate-leaf="true" data-offset-key="990:0" data-first-offset="true"><span data-slate-string="true">下面我举一个例子。我们知道 device-year-class 会根据手机的内存、CPU 核心数和频率等信息决定设备属于哪一个年份，这个示例表示对于 2013 年之后的设备可以使用复杂的动画，对于 2010 年之前的低端设备则不添加任何动画。</span></span></span></div><div class="se-046d202f" data-code-language="javascript" data-slate-type="pre" data-slate-object="block" data-key="991"><div class="se-4d314963 se-353033bc"><span></span></div><div class="se-a7a2dac3"><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="1"></div><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="2"></div><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="3"></div><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="4"></div><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="5"></div><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="6"></div><div class="se-e0d460d1 se-5675c0bf" data-code-line-number="7"></div></div><div class="se-0bc09103 ps"><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="992"><span data-slate-object="text" data-key="993"><span data-slate-leaf="true" data-offset-key="993:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">if</span></span></span></span><span data-slate-object="text" data-key="994"><span data-slate-leaf="true" data-offset-key="994:0" data-first-offset="true"><span data-slate-string="true"> (year &gt;= </span></span></span><span data-slate-object="text" data-key="995"><span data-slate-leaf="true" data-offset-key="995:0" data-first-offset="true"><span class="hljs-number" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">2013</span></span></span></span><span data-slate-object="text" data-key="996"><span data-slate-leaf="true" data-offset-key="996:0" data-first-offset="true"><span data-slate-string="true">) {</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="997"><span data-slate-object="text" data-key="998"><span data-slate-leaf="true" data-offset-key="998:0" data-first-offset="true"><span data-slate-string="true">    </span></span></span><span data-slate-object="text" data-key="999"><span data-slate-leaf="true" data-offset-key="999:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// Do advanced animation</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1000"><span data-slate-object="text" data-key="1001"><span data-slate-leaf="true" data-offset-key="1001:0" data-first-offset="true"><span data-slate-string="true">} </span></span></span><span data-slate-object="text" data-key="1002"><span data-slate-leaf="true" data-offset-key="1002:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">else</span></span></span></span><span data-slate-object="text" data-key="1003"><span data-slate-leaf="true" data-offset-key="1003:0" data-first-offset="true"><span data-slate-string="true"> </span></span></span><span data-slate-object="text" data-key="1004"><span data-slate-leaf="true" data-offset-key="1004:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">if</span></span></span></span><span data-slate-object="text" data-key="1005"><span data-slate-leaf="true" data-offset-key="1005:0" data-first-offset="true"><span data-slate-string="true"> (year &gt;= </span></span></span><span data-slate-object="text" data-key="1006"><span data-slate-leaf="true" data-offset-key="1006:0" data-first-offset="true"><span class="hljs-number" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">2010</span></span></span></span><span data-slate-object="text" data-key="1007"><span data-slate-leaf="true" data-offset-key="1007:0" data-first-offset="true"><span data-slate-string="true">) {</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1008"><span data-slate-object="text" data-key="1009"><span data-slate-leaf="true" data-offset-key="1009:0" data-first-offset="true"><span data-slate-string="true">    </span></span></span><span data-slate-object="text" data-key="1010"><span data-slate-leaf="true" data-offset-key="1010:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// Do simple animation</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1011"><span data-slate-object="text" data-key="1012"><span data-slate-leaf="true" data-offset-key="1012:0" data-first-offset="true"><span data-slate-string="true">} </span></span></span><span data-slate-object="text" data-key="1013"><span data-slate-leaf="true" data-offset-key="1013:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">else</span></span></span></span><span data-slate-object="text" data-key="1014"><span data-slate-leaf="true" data-offset-key="1014:0" data-first-offset="true"><span data-slate-string="true"> {</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1015"><span data-slate-object="text" data-key="1016"><span data-slate-leaf="true" data-offset-key="1016:0" data-first-offset="true"><span data-slate-string="true">    </span></span></span><span data-slate-object="text" data-key="1017"><span data-slate-leaf="true" data-offset-key="1017:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// Phone too slow, don't do any animations</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1018"><span data-slate-object="text" data-key="1019"><span data-slate-leaf="true" data-offset-key="1019:0" data-first-offset="true"><span data-slate-string="true">}</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div><div class="se-427e25eb" data-slate-type="list" data-slate-object="block" data-key="1020"><div class="se-0cb1b56c se-e5e0819b" data-slate-type="list-line" data-slate-object="block" data-key="1021"><span data-slate-object="text" data-key="1022"><span data-slate-leaf="true" data-offset-key="1022:0" data-first-offset="true"><span data-slate-string="true">缓存管理。我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 OnTrimMemory 回调，根据不同的状态决定释放多少内存。对于大项目来说，可能存在几十上百个模块，统一缓存管理可以更好地监控每个模块的缓存大小。</span></span></span></div><div class="se-e90984d1 se-251ef449" data-slate-type="list-line" data-slate-object="block" data-key="1023"><span data-slate-object="text" data-key="1024"><span data-slate-leaf="true" data-offset-key="1024:0" data-first-offset="true"><span class="se-ecb58a1c" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">进程模型</span></span></span></span><span data-slate-object="text" data-key="1025"><span data-slate-leaf="true" data-offset-key="1025:0" data-first-offset="true"><span data-slate-string="true">。一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</span></span></span></div><div class="se-3664e80b se-96dd9494" data-slate-type="list-line" data-slate-object="block" data-key="1026"><span data-slate-object="text" data-key="1027"><span data-slate-leaf="true" data-offset-key="1027:0" data-first-offset="true"><span data-slate-string="true">安装包大小。安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 Facebook Lite、今日头条极速版都是这个思路。</span></span></span></div></div><div class="se-8ea1c954 " data-slate-type="paragraph" data-slate-object="block" data-key="1028"><span data-slate-object="text" data-key="1029"><span data-slate-leaf="true" data-offset-key="1029:0" data-first-offset="true"><span data-slate-string="true">安装包中的代码、图片、资源以及 so 库的大小跟内存究竟有哪些关系？你可以参考下面的这个表格。</span></span></span></div><div class="se-b5fec19a" data-slate-type="image" data-slate-object="block" data-key="1030"><img class="se-727a709d" src="https://static001.geekbang.org/resource/image/0b/a9/0bbcbc6862d0d5f86b8e42d25231b5a9.png"></div><div class="se-d59d061a " data-slate-type="paragraph" data-slate-object="block" data-key="1031"><span data-slate-object="text" data-key="1032"><span data-slate-leaf="true" data-offset-key="1032:0" data-first-offset="true"><span class="se-a5696f18" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">2. Bitmap 优化</span></span></span></span></div><div class="se-b61691e6 " data-slate-type="paragraph" data-slate-object="block" data-key="1033"><span data-slate-object="text" data-key="1034"><span data-slate-leaf="true" data-offset-key="1034:0" data-first-offset="true"><span data-slate-string="true">Bitmap 内存一般占应用总内存很大一部分，所以做内存优化永远无法避开图片内存这个“永恒主题”。</span></span></span></div><div class="se-0328b0b0 " data-slate-type="paragraph" data-slate-object="block" data-key="1035"><span data-slate-object="text" data-key="1036"><span data-slate-leaf="true" data-offset-key="1036:0" data-first-offset="true"><span data-slate-string="true">即使把所有的 Bitmap 都放到 Native 内存，并不代表图片内存问题就完全解决了，这样做只是提升了系统内存利用率，减少了 GC 带来的一些问题而已。</span></span></span></div><div class="se-4f5a5cc1 " data-slate-type="paragraph" data-slate-object="block" data-key="1037"><span data-slate-object="text" data-key="1038"><span data-slate-leaf="true" data-offset-key="1038:0" data-first-offset="true"><span data-slate-string="true">那我们回过头来看看，到底该如何优化图片内存呢？我给你介绍两种方法。</span></span></span></div><div class="se-0e0b4f49 " data-slate-type="paragraph" data-slate-object="block" data-key="1039"><span data-slate-object="text" data-key="1040"><span data-slate-leaf="true" data-offset-key="1040:0" data-first-offset="true"><span class="se-2fc3b1fd" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">方法一，统一图片库。</span></span></span></span></div><div class="se-1f63f790 " data-slate-type="paragraph" data-slate-object="block" data-key="1041"><span data-slate-object="text" data-key="1042"><span data-slate-leaf="true" data-offset-key="1042:0" data-first-offset="true"><span data-slate-string="true">图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。例如低端机使用 565 格式、更加严格的缩放算法，可以使用 Glide、Fresco 或者采取自研都可以。而且需要进一步将所有 Bitmap.createBitmap、BitmapFactory 相关的接口也一并收拢。</span></span></span></div><div class="se-183846d3 " data-slate-type="paragraph" data-slate-object="block" data-key="1043"><span data-slate-object="text" data-key="1044"><span data-slate-leaf="true" data-offset-key="1044:0" data-first-offset="true"><span class="se-edb2759e" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">方法二，统一监控。</span></span></span></span></div><div class="se-55f50b84 " data-slate-type="paragraph" data-slate-object="block" data-key="1045"><span data-slate-object="text" data-key="1046"><span data-slate-leaf="true" data-offset-key="1046:0" data-first-offset="true"><span data-slate-string="true">在统一图片库后就非常容易监控 Bitmap 的使用情况了，这里主要有三点需要注意。</span></span></span></div><div class="se-8f09311f" data-slate-type="list" data-slate-object="block" data-key="1047"><div class="se-88e17e28 se-475b294a" data-slate-type="list-line" data-slate-object="block" data-key="1048"><span data-slate-object="text" data-key="1049"><span data-slate-leaf="true" data-offset-key="1049:0" data-first-offset="true"><span data-slate-string="true">大图片监控。我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。在灰度和线上环境下可以将异常信息上报到后台，我们可以计算有多少比例的图片会超过屏幕的大小，也就是图片的</span></span></span><span data-slate-object="text" data-key="1050"><span data-slate-leaf="true" data-offset-key="1050:0" data-first-offset="true"><span class="se-8347320f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">“超宽率”</span></span></span></span><span data-slate-object="text" data-key="1051"><span data-slate-leaf="true" data-offset-key="1051:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span></div><div class="se-1a5ccef8 se-982800e7" data-slate-type="list-line" data-slate-object="block" data-key="1052"><span data-slate-object="text" data-key="1053"><span data-slate-leaf="true" data-offset-key="1053:0" data-first-offset="true"><span data-slate-string="true">重复图片监控。重复图片指的是 Bitmap 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。</span></span></span><span data-slate-object="text" data-key="1054"><span data-slate-leaf="true" data-offset-key="1054:0" data-first-offset="true"><span class="se-1f9c430d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">之前我实现过一个内存 Hprof 的分析工具，它可以自动将重复 Bitmap 的图片和引用链输出</span></span></span></span><span data-slate-object="text" data-key="1055"><span data-slate-leaf="true" data-offset-key="1055:0" data-first-offset="true"><span data-slate-string="true">。下图是一个简单的例子，你可以看到两张图片的内容完全一样，通过解决这张重复图片可以节省 1MB 内存。</span></span></span></div></div><div class="se-6c7956c8" data-slate-type="image" data-slate-object="block" data-key="1056"><img class="se-97dd1c03" src="https://static001.geekbang.org/resource/image/bb/ae/bbeb46e2a974f2cdf7fb3b8fdbf5afae.png"></div><div class="se-2156e60a" data-slate-type="list" data-slate-object="block" data-key="1057"><div class="se-48329bd2 se-120fa964" data-slate-type="list-line" data-slate-object="block" data-key="1058"><span data-slate-object="text" data-key="1059"><span data-slate-leaf="true" data-offset-key="1059:0" data-first-offset="true"><span data-slate-string="true">图片总内存。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。</span></span></span><span data-slate-object="text" data-key="1060"><span data-slate-leaf="true" data-offset-key="1060:0" data-first-offset="true"><span class="se-77ef1446" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">在 OOM 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题</span></span></span></span><span data-slate-object="text" data-key="1061"><span data-slate-leaf="true" data-offset-key="1061:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span></div></div><div class="se-64712ad9 " data-slate-type="paragraph" data-slate-object="block" data-key="1062"><span data-slate-object="text" data-key="1063"><span data-slate-leaf="true" data-offset-key="1063:0" data-first-offset="true"><span data-slate-string="true">讲完设备分级和 Bitmap 优化，我们发现架构和监控需要两手抓，一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题。</span></span></span></div><div class="se-0f567e23 " data-slate-type="paragraph" data-slate-object="block" data-key="1064"><span data-slate-object="text" data-key="1065"><span data-slate-leaf="true" data-offset-key="1065:0" data-first-offset="true"><span class="se-0f3783cb" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">3. 内存泄漏</span></span></span></span></div><div class="se-2cc33581 " data-slate-type="paragraph" data-slate-object="block" data-key="1066"><span data-slate-object="text" data-key="1067"><span data-slate-leaf="true" data-offset-key="1067:0" data-first-offset="true"><span data-slate-string="true">内存泄漏简单来说就是没有回收不再使用的内存，排查和解决内存泄漏也是内存优化无法避开的工作之一。</span></span></span></div><div class="se-99fc94c1 " data-slate-type="paragraph" data-slate-object="block" data-key="1068"><span data-slate-object="text" data-key="1069"><span data-slate-leaf="true" data-offset-key="1069:0" data-first-offset="true"><span data-slate-string="true">内存泄漏主要分两种情况，一种是同一个对象泄漏，还有一种情况更加糟糕，就是每次都会泄漏新的对象，可能会出现几百上千个无用的对象。</span></span></span></div><div class="se-bef379f6 " data-slate-type="paragraph" data-slate-object="block" data-key="1070"><span data-slate-object="text" data-key="1071"><span data-slate-leaf="true" data-offset-key="1071:0" data-first-offset="true"><span data-slate-string="true">很多内存泄漏都是框架设计不合理所导致，各种各样的单例满天飞，MVC 中 Controller 的生命周期远远大于 View。优秀的框架设计可以减少甚至避免程序员犯错，当然这不是一件容易的事情，所以我们还需要对内存泄漏建立持续的监控。</span></span></span></div><div class="se-384d64a9" data-slate-type="list" data-slate-object="block" data-key="1072"><div class="se-d5474789 se-fbbed5e4" data-slate-type="list-line" data-slate-object="block" data-key="1073"><span data-slate-object="text" data-key="1074"><span data-slate-leaf="true" data-offset-key="1074:0" data-first-offset="true"><span class="se-6ca8118f" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Java 内存泄漏</span></span></span></span><span data-slate-object="text" data-key="1075"><span data-slate-leaf="true" data-offset-key="1075:0" data-first-offset="true"><span data-slate-string="true">。建立类似 LeakCanary 自动化检测方案，至少做到 Activity 和 Fragment 的泄漏检测。在开发过程，我们希望出现泄漏时可以弹出对话框，让开发者更加容易去发现和解决问题。内存泄漏监控放到线上并不容易，我们可以对生成的 Hprof 内存快照文件做一些优化，裁剪大部分图片对应的 byte 数组减少文件大小。</span></span></span><span data-slate-object="text" data-key="1076"><span data-slate-leaf="true" data-offset-key="1076:0" data-first-offset="true"><span class="se-2c6a038c" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">比如一个 100MB 的文件裁剪后一般只剩下 30MB 左右，使用 7zip 压缩最后小于 10MB，增加了文件上传的成功率</span></span></span></span><span data-slate-object="text" data-key="1077"><span data-slate-leaf="true" data-offset-key="1077:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span></div></div><div class="se-6624de18" data-slate-type="image" data-slate-object="block" data-key="1078"><img class="se-9714393f" src="https://static001.geekbang.org/resource/image/3d/85/3d917345c8c8462f8a419568c7d73085.png"></div><div class="se-7847a542" data-slate-type="list" data-slate-object="block" data-key="1079"><div class="se-6ca51fdb se-37ca3c4d" data-slate-type="list-line" data-slate-object="block" data-key="1080"><span data-slate-object="text" data-key="1081"><span data-slate-leaf="true" data-offset-key="1081:0" data-first-offset="true"><span class="se-2dc9eb15" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">OOM 监控</span></span></span></span><span data-slate-object="text" data-key="1082"><span data-slate-leaf="true" data-offset-key="1082:0" data-first-offset="true"><span data-slate-string="true">。美团有一个 Android 内存泄露自动化链路分析组件</span></span></span><a data-slate-type="link" data-slate-object="inline" data-key="1083" class="se-de03e9b6 se-555e961b"><span data-slate-object="text" data-key="1084"><span data-slate-leaf="true" data-offset-key="1084:0" data-first-offset="true"><span data-slate-string="true">Probe</span></span></span></a><span data-slate-object="text" data-key="1085"><span data-slate-leaf="true" data-offset-key="1085:0" data-first-offset="true"><span data-slate-string="true">，它在发生 OOM 的时候生成 Hprof 内存快照，然后通过单独进程对这个文件做进一步的分析。不过在线上使用这个工具风险还是比较大，在崩溃的时候生成内存快照</span></span></span><span data-slate-object="text" data-key="1086"><span data-slate-leaf="true" data-offset-key="1086:0" data-first-offset="true"><span class="se-3f6994cc" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">有可能会导致二次崩溃</span></span></span></span><span data-slate-object="text" data-key="1087"><span data-slate-leaf="true" data-offset-key="1087:0" data-first-offset="true"><span data-slate-string="true">，而且部分手机生成 Hprof 快照可能会耗时几分钟，这对用户造成的体验影响会比较大。另外，部分 OOM 是因为虚拟内存不足导致，这块需要具体问题具体分析。</span></span></span></div><div class="se-ab609fa4 se-67335d8c" data-slate-type="list-line" data-slate-object="block" data-key="1088"><span data-slate-object="text" data-key="1089"><span data-slate-leaf="true" data-offset-key="1089:0" data-first-offset="true"><span class="se-d3f92955" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Native 内存泄漏监控</span></span></span></span><span data-slate-object="text" data-key="1090"><span data-slate-leaf="true" data-offset-key="1090:0" data-first-offset="true"><span data-slate-string="true">。上一期我讲到 Malloc 调试（Malloc Debug）和 Malloc 钩子（Malloc Hook）似乎还不是那么稳定。在 WeMobileDev 最近的一篇文章</span></span></span><a data-slate-type="link" data-slate-object="inline" data-key="1091" class="se-de03e9b6 se-555e961b"><span data-slate-object="text" data-key="1092"><span data-slate-leaf="true" data-offset-key="1092:0" data-first-offset="true"><span data-slate-string="true">《微信 Android 终端内存优化实践》</span></span></span></a><span data-slate-object="text" data-key="1093"><span data-slate-leaf="true" data-offset-key="1093:0" data-first-offset="true"><span data-slate-string="true">中，微信也做了一些其他方案上面的尝试。</span></span></span></div><div class="se-18296a73 se-a97eae2b" data-slate-type="list-line" data-slate-object="block" data-key="1094"><span data-slate-object="text" data-key="1095"><span data-slate-leaf="true" data-offset-key="1095:0" data-first-offset="true"><span class="se-b21a04c6" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">针对无法重编 so 的情况</span></span></span></span><span data-slate-object="text" data-key="1096"><span data-slate-leaf="true" data-offset-key="1096:0" data-first-offset="true"><span data-slate-string="true">，使用了 PLT Hook 拦截库的内存分配函数，其中 PLT Hook 是 Native Hook 的一种方案，后面我们还会讲到。然后重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 库路径等信息，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。</span></span></span></div><div class="se-9efda741 se-e6b260f8" data-slate-type="list-line" data-slate-object="block" data-key="1097"><span data-slate-object="text" data-key="1098"><span data-slate-leaf="true" data-offset-key="1098:0" data-first-offset="true"><span class="se-9d042a4d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">针对可重编的 so 情况</span></span></span></span><span data-slate-object="text" data-key="1099"><span data-slate-leaf="true" data-offset-key="1099:0" data-first-offset="true"><span data-slate-string="true">，通过 GCC 的“-finstrument-functions”参数给所有函数插桩，桩中模拟调用栈入栈出栈操作；通过 ld 的“–wrap”参数拦截内存分配和释放函数，重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 以及插桩记录的调用栈此刻的内容，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。</span></span></span></div></div><div class="se-4096006c " data-slate-type="paragraph" data-slate-object="block" data-key="1100"><span data-slate-object="text" data-key="1101"><span data-slate-leaf="true" data-offset-key="1101:0" data-first-offset="true"><span data-slate-string="true">开发过程中内存泄漏排查可以使用 Androd Profiler 和 MAT 工具配合使用，而日常监控关键是成体系化，做到及时发现问题。</span></span></span></div><div class="se-7ae02ca7 " data-slate-type="paragraph" data-slate-object="block" data-key="1102"><span data-slate-object="text" data-key="1103"><span data-slate-leaf="true" data-offset-key="1103:0" data-first-offset="true"><span data-slate-string="true">坦白地说，除了 Java 泄漏检测方案，目前 OOM 监控和 Native 内存泄漏监控都只能做到实验室自动化测试的水平。微信的 Native 监控方案也遇到一些兼容性的问题，如果想达到灰度和线上部署，需要考虑的细节会非常多。Native 内存泄漏检测在 iOS 会简单一些，不过 Google 也在一直优化 Native 内存泄漏检测的性能和易用性，相信在未来的 Android 版本将会有很大改善。</span></span></span></div><h2 class="se-879ef03f" data-slate-type="heading" data-slate-object="block" data-key="1104"><span data-slate-object="text" data-key="1105"><span data-slate-leaf="true" data-offset-key="1105:0" data-first-offset="true"><span data-slate-string="true">内存监控</span></span></span></h2><div class="se-6dbb29f8 " data-slate-type="paragraph" data-slate-object="block" data-key="1106"><span data-slate-object="text" data-key="1107"><span data-slate-leaf="true" data-offset-key="1107:0" data-first-offset="true"><span data-slate-string="true">前面我也提了内存泄漏的监控存在一些性能的问题，一般只会对内部人员和极少部分的用户开启。在线上我们需要通过其他更有效的方式去监控内存相关的问题。</span></span></span></div><div class="se-6f869292 " data-slate-type="paragraph" data-slate-object="block" data-key="1108"><span data-slate-object="text" data-key="1109"><span data-slate-leaf="true" data-offset-key="1109:0" data-first-offset="true"><span class="se-25208d7e" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">1. 采集方式</span></span></span></span></div><div class="se-5ec96267 " data-slate-type="paragraph" data-slate-object="block" data-key="1110"><span data-slate-object="text" data-key="1111"><span data-slate-leaf="true" data-offset-key="1111:0" data-first-offset="true"><span data-slate-string="true">用户在前台的时候，可以每 5 分钟采集一次 PSS、Java 堆、图片总内存。我建议通过采样只统计部分用户，需要注意的是要按照用户抽样，而不是按次抽样。简单来说一个用户如果命中采集，那么在一天内都要持续采集数据。</span></span></span></div><div class="se-729d00d6 " data-slate-type="paragraph" data-slate-object="block" data-key="1112"><span data-slate-object="text" data-key="1113"><span data-slate-leaf="true" data-offset-key="1113:0" data-first-offset="true"><span class="se-9e620136" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">2. 计算指标</span></span></span></span></div><div class="se-3960b369 " data-slate-type="paragraph" data-slate-object="block" data-key="1114"><span data-slate-object="text" data-key="1115"><span data-slate-leaf="true" data-offset-key="1115:0" data-first-offset="true"><span data-slate-string="true">通过上面的数据，我们可以计算下面一些内存指标。</span></span></span></div><div class="se-e3622c25 " data-slate-type="paragraph" data-slate-object="block" data-key="1116"><span data-slate-object="text" data-key="1117"><span data-slate-leaf="true" data-offset-key="1117:0" data-first-offset="true"><span class="se-81672fc8" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">内存异常率</span></span></span></span><span data-slate-object="text" data-key="1118"><span data-slate-leaf="true" data-offset-key="1118:0" data-first-offset="true"><span data-slate-string="true">：可以反映内存占用的异常情况，如果出现新的内存使用不当或内存泄漏的场景，这个指标会有所上涨。其中 PSS 的值可以通过 Debug.MemoryInfo 拿到。</span></span></span></div><div class="se-b600b166" data-slate-type="pre" data-slate-object="block" data-key="1119"><div class="se-899b2ed3 se-abb8e7e9"><span></span></div><div class="se-9db91a9e"><div class="se-fca725ed se-c4bbf228" data-code-line-number="1"></div></div><div class="se-6580ad22 ps"><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1120"><span data-slate-object="text" data-key="1121"><span data-slate-leaf="true" data-offset-key="1121:0" data-first-offset="true"><span data-slate-string="true">内存 UV 异常率 = PSS 超过 400MB 的 UV / 采集 UV</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div><div class="se-6e22781d " data-slate-type="paragraph" data-slate-object="block" data-key="1122"><span data-slate-object="text" data-key="1123"><span data-slate-leaf="true" data-offset-key="1123:0" data-first-offset="true"><span class="se-1b901812" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">触顶率</span></span></span></span><span data-slate-object="text" data-key="1124"><span data-slate-leaf="true" data-offset-key="1124:0" data-first-offset="true"><span data-slate-string="true">：可以反映 Java 内存的使用情况，如果超过 85% 最大堆限制，GC 会变得更加频繁，容易造成 OOM 和卡顿。</span></span></span></div><div class="se-b44deafd" data-slate-type="pre" data-slate-object="block" data-key="1125"><div class="se-27d93f4e se-98fe75a3"><span></span></div><div class="se-a7657251"><div class="se-9fb18892 se-df0cdf1a" data-code-line-number="1"></div></div><div class="se-15457f20 ps"><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1126"><span data-slate-object="text" data-key="1127"><span data-slate-leaf="true" data-offset-key="1127:0" data-first-offset="true"><span data-slate-string="true">内存 UV 触顶率 = Java 堆占用超过最大堆限制的 85% 的 UV / 采集 UV</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div><div class="se-c9058930 " data-slate-type="paragraph" data-slate-object="block" data-key="1128"><span data-slate-object="text" data-key="1129"><span data-slate-leaf="true" data-offset-key="1129:0" data-first-offset="true"><span data-slate-string="true">其中是否触顶可以通过下面的方法计算得到。</span></span></span></div><div class="se-fd639b2a" data-code-language="java" data-slate-type="pre" data-slate-object="block" data-key="1130"><div class="se-c808a6be se-67ba2398"><span></span></div><div class="se-e81425d5"><div class="se-8de78333 se-bf3859a1" data-code-line-number="1"></div><div class="se-8de78333 se-bf3859a1" data-code-line-number="2"></div><div class="se-8de78333 se-bf3859a1" data-code-line-number="3"></div><div class="se-8de78333 se-bf3859a1" data-code-line-number="4"></div><div class="se-8de78333 se-bf3859a1" data-code-line-number="5"></div></div><div class="se-4ba5e95f ps"><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1131"><span data-slate-object="text" data-key="1132"><span data-slate-leaf="true" data-offset-key="1132:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">long</span></span></span></span><span data-slate-object="text" data-key="1133"><span data-slate-leaf="true" data-offset-key="1133:0" data-first-offset="true"><span data-slate-string="true"> javaMax = runtime.maxMemory();</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1134"><span data-slate-object="text" data-key="1135"><span data-slate-leaf="true" data-offset-key="1135:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">long</span></span></span></span><span data-slate-object="text" data-key="1136"><span data-slate-leaf="true" data-offset-key="1136:0" data-first-offset="true"><span data-slate-string="true"> javaTotal = runtime.totalMemory();</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1137"><span data-slate-object="text" data-key="1138"><span data-slate-leaf="true" data-offset-key="1138:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">long</span></span></span></span><span data-slate-object="text" data-key="1139"><span data-slate-leaf="true" data-offset-key="1139:0" data-first-offset="true"><span data-slate-string="true"> javaUsed = javaTotal - runtime.freeMemory();</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1140"><span data-slate-object="text" data-key="1141"><span data-slate-leaf="true" data-offset-key="1141:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// Java 内存使用超过最大限制的 85%</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1142"><span data-slate-object="text" data-key="1143"><span data-slate-leaf="true" data-offset-key="1143:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">float</span></span></span></span><span data-slate-object="text" data-key="1144"><span data-slate-leaf="true" data-offset-key="1144:0" data-first-offset="true"><span data-slate-string="true"> proportion = (</span></span></span><span data-slate-object="text" data-key="1145"><span data-slate-leaf="true" data-offset-key="1145:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">float</span></span></span></span><span data-slate-object="text" data-key="1146"><span data-slate-leaf="true" data-offset-key="1146:0" data-first-offset="true"><span data-slate-string="true">) javaUsed / javaMax;</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div><div class="se-44f1b036 " data-slate-type="paragraph" data-slate-object="block" data-key="1147"><span data-slate-object="text" data-key="1148"><span data-slate-leaf="true" data-offset-key="1148:0" data-first-offset="true"><span data-slate-string="true">一般客户端只上报数据，所有计算都在后台处理，这样可以做到灵活多变。后台还可以计算平均 PSS、平均 Java 内存、</span></span></span><span data-slate-object="text" data-key="1149"><span data-slate-leaf="true" data-offset-key="1149:0" data-first-offset="true"><span class="se-178e119d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">平均图片占用</span></span></span></span><span data-slate-object="text" data-key="1150"><span data-slate-leaf="true" data-offset-key="1150:0" data-first-offset="true"><span data-slate-string="true">这些指标，它们可以反映内存的平均情况。通过平均内存和分区间内存占用这些指标，我们可以通过版本对比来监控有没有新增内存相关的问题。</span></span></span></div><div class="se-5b5e1431" data-slate-type="image" data-slate-object="block" data-key="1151"><img class="se-db5d02b1" src="https://static001.geekbang.org/resource/image/65/ec/65e0b02933c1f7fe181b83d69587e7ec.jpg"></div><div class="se-26803469 " data-slate-type="paragraph" data-slate-object="block" data-key="1152"><span data-slate-object="text" data-key="1153"><span data-slate-leaf="true" data-offset-key="1153:0" data-first-offset="true"><span data-slate-string="true">因为上报了前台时间，我们还可以按照时间维度看应用内存的变化曲线。比如可以观察一下我们的应用是不是真正做到了</span></span></span><span data-slate-object="text" data-key="1154"><span data-slate-leaf="true" data-offset-key="1154:0" data-first-offset="true"><span class="se-142a6f78" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">“用时分配，及时释放”</span></span></span></span><span data-slate-object="text" data-key="1155"><span data-slate-leaf="true" data-offset-key="1155:0" data-first-offset="true"><span data-slate-string="true">。如果需要，我们还可以实现按照场景来对比内存的占用。</span></span></span></div><div class="se-d1d147fa " data-slate-type="paragraph" data-slate-object="block" data-key="1156"><span data-slate-object="text" data-key="1157"><span data-slate-leaf="true" data-offset-key="1157:0" data-first-offset="true"><span class="se-36d89237" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">3. GC 监控</span></span></span></span></div><div class="se-065fe22c " data-slate-type="paragraph" data-slate-object="block" data-key="1158"><span data-slate-object="text" data-key="1159"><span data-slate-leaf="true" data-offset-key="1159:0" data-first-offset="true"><span data-slate-string="true">在实验室或者内部试用环境，我们也可以通过 Debug.startAllocCounting 来监控 Java 内存分配和 GC 的情况，需要注意的是这个选项对性能有一定的影响，虽然目前还可以使用，但已经被 Android 标记为 deprecated。</span></span></span></div><div class="se-d4ba41bd " data-slate-type="paragraph" data-slate-object="block" data-key="1160"><span data-slate-object="text" data-key="1161"><span data-slate-leaf="true" data-offset-key="1161:0" data-first-offset="true"><span data-slate-string="true">通过监控，我们可以拿到内存分配的次数和大小，以及 GC 发起次数等信息。</span></span></span></div><div class="se-a4b82d97" data-code-language="java" data-slate-type="pre" data-slate-object="block" data-key="1162"><div class="se-80ae464c se-cfaa5878"><span></span></div><div class="se-c44e520d"><div class="se-1cb1665d se-05778a6a" data-code-line-number="1"></div><div class="se-1cb1665d se-05778a6a" data-code-line-number="2"></div><div class="se-1cb1665d se-05778a6a" data-code-line-number="3"></div></div><div class="se-66dc03a8 ps"><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1163"><span data-slate-object="text" data-key="1164"><span data-slate-leaf="true" data-offset-key="1164:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">long</span></span></span></span><span data-slate-object="text" data-key="1165"><span data-slate-leaf="true" data-offset-key="1165:0" data-first-offset="true"><span data-slate-string="true"> allocCount = Debug.getGlobalAllocCount();</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1166"><span data-slate-object="text" data-key="1167"><span data-slate-leaf="true" data-offset-key="1167:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">long</span></span></span></span><span data-slate-object="text" data-key="1168"><span data-slate-leaf="true" data-offset-key="1168:0" data-first-offset="true"><span data-slate-string="true"> allocSize = Debug.getGlobalAllocSize();</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1169"><span data-slate-object="text" data-key="1170"><span data-slate-leaf="true" data-offset-key="1170:0" data-first-offset="true"><span class="hljs-keyword" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">long</span></span></span></span><span data-slate-object="text" data-key="1171"><span data-slate-leaf="true" data-offset-key="1171:0" data-first-offset="true"><span data-slate-string="true"> gcCount = Debug.getGlobalGcInvocationCount();</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div><div class="se-86def1bd " data-slate-type="paragraph" data-slate-object="block" data-key="1172"><span data-slate-object="text" data-key="1173"><span data-slate-leaf="true" data-offset-key="1173:0" data-first-offset="true"><span data-slate-string="true">上面的这些信息似乎不太容易定位问题，在 Android 6.0 之后系统可以拿到更加精准的 GC 信息。</span></span></span></div><div class="se-b7017691" data-code-language="javascript" data-slate-type="pre" data-slate-object="block" data-key="1174"><div class="se-95e05741 se-c3f2c98e"><span></span></div><div class="se-a2345f6b"><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="1"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="2"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="3"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="4"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="5"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="6"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="7"></div><div class="se-5a03a8e5 se-5c4a291b" data-code-line-number="8"></div></div><div class="se-8280b74d ps"><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1175"><span data-slate-object="text" data-key="1176"><span data-slate-leaf="true" data-offset-key="1176:0" data-first-offset="true"><span data-slate-string="true">﻿﻿</span></span></span><span data-slate-object="text" data-key="1177"><span data-slate-leaf="true" data-offset-key="1177:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// 运行的GC次数</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1178"><span data-slate-object="text" data-key="1179"><span data-slate-leaf="true" data-offset-key="1179:0" data-first-offset="true"><span data-slate-string="true">Debug.getRuntimeStat(</span></span></span><span data-slate-object="text" data-key="1180"><span data-slate-leaf="true" data-offset-key="1180:0" data-first-offset="true"><span class="hljs-string" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">"art.gc.gc-count"</span></span></span></span><span data-slate-object="text" data-key="1181"><span data-slate-leaf="true" data-offset-key="1181:0" data-first-offset="true"><span data-slate-string="true">);</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1182"><span data-slate-object="text" data-key="1183"><span data-slate-leaf="true" data-offset-key="1183:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// GC使用的总耗时，单位是毫秒</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1184"><span data-slate-object="text" data-key="1185"><span data-slate-leaf="true" data-offset-key="1185:0" data-first-offset="true"><span data-slate-string="true">Debug.getRuntimeStat(</span></span></span><span data-slate-object="text" data-key="1186"><span data-slate-leaf="true" data-offset-key="1186:0" data-first-offset="true"><span class="hljs-string" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">"art.gc.gc-time"</span></span></span></span><span data-slate-object="text" data-key="1187"><span data-slate-leaf="true" data-offset-key="1187:0" data-first-offset="true"><span data-slate-string="true">);</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1188"><span data-slate-object="text" data-key="1189"><span data-slate-leaf="true" data-offset-key="1189:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// 阻塞式GC的次数</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1190"><span data-slate-object="text" data-key="1191"><span data-slate-leaf="true" data-offset-key="1191:0" data-first-offset="true"><span data-slate-string="true">Debug.getRuntimeStat(</span></span></span><span data-slate-object="text" data-key="1192"><span data-slate-leaf="true" data-offset-key="1192:0" data-first-offset="true"><span class="hljs-string" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">"art.gc.blocking-gc-count"</span></span></span></span><span data-slate-object="text" data-key="1193"><span data-slate-leaf="true" data-offset-key="1193:0" data-first-offset="true"><span data-slate-string="true">);</span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1194"><span data-slate-object="text" data-key="1195"><span data-slate-leaf="true" data-offset-key="1195:0" data-first-offset="true"><span class="hljs-comment" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">// 阻塞式GC的总耗时</span></span></span></span></div><div class="se-ad60a47e se-edf32a81" data-slate-type="code-line" data-slate-object="block" data-key="1196"><span data-slate-object="text" data-key="1197"><span data-slate-leaf="true" data-offset-key="1197:0" data-first-offset="true"><span data-slate-string="true">Debug.getRuntimeStat(</span></span></span><span data-slate-object="text" data-key="1198"><span data-slate-leaf="true" data-offset-key="1198:0" data-first-offset="true"><span class="hljs-string" data-slate-type="mark-class" data-slate-object="mark"><span data-slate-string="true">"art.gc.blocking-gc-time"</span></span></span></span><span data-slate-object="text" data-key="1199"><span data-slate-leaf="true" data-offset-key="1199:0" data-first-offset="true"><span data-slate-string="true">);</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div><div class="se-b77a2fdd " data-slate-type="paragraph" data-slate-object="block" data-key="1200"><span data-slate-object="text" data-key="1201"><span data-slate-leaf="true" data-offset-key="1201:0" data-first-offset="true"><span data-slate-string="true">需要特别注意阻塞式 GC 的次数和耗时，因为它会暂停应用线程，可能导致应用发生卡顿。我们也可以更加细粒度地分应用场景统计，例如启动、进入朋友圈、进入聊天页面等关键场景。</span></span></span></div><h2 class="se-0f631ef3" data-slate-type="heading" data-slate-object="block" data-key="1202"><span data-slate-object="text" data-key="1203"><span data-slate-leaf="true" data-offset-key="1203:0" data-first-offset="true"><span data-slate-string="true">总结</span></span></span></h2><div class="se-cae50d11 " data-slate-type="paragraph" data-slate-object="block" data-key="1204"><span data-slate-object="text" data-key="1205"><span data-slate-leaf="true" data-offset-key="1205:0" data-first-offset="true"><span data-slate-string="true">在具体进行内容优化前，我们首先要问清楚自己几个问题，比如我们要优化到什么目标、内存对我们造成了多少异常和卡顿。只有在明确了应用的现状和优化目标后，我们才能去进行下一步的操作。</span></span></span></div><div class="se-ca7c8530 " data-slate-type="paragraph" data-slate-object="block" data-key="1206"><span data-slate-object="text" data-key="1207"><span data-slate-leaf="true" data-offset-key="1207:0" data-first-offset="true"><span data-slate-string="true">在探讨了内存优化的思路时，针对不同的设备、设备不同的情况，我们希望可以给用户不同的体验。这里我主要讲到了关于 Bitmap 内存优化和内存泄漏排查、监控的一些方法。最后我提到了怎样在线上监控内存的异常情况，通常内存异常率、触顶率这些指标对我们很有帮助。</span></span></span></div><div class="se-c44218e1 " data-slate-type="paragraph" data-slate-object="block" data-key="1208"><span data-slate-object="text" data-key="1209"><span data-slate-leaf="true" data-offset-key="1209:0" data-first-offset="true"><span class="se-c43dc0fe" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">目前我们在 Native 泄漏分析上做的还不是那么完善，不过做优化工作的时候，我特别喜欢用演进的思路来看问题。用演进的思路来看，即使是 Google， 在时机不成熟时也会做一些权衡和妥协。换到我们个人身上，等到时机成熟或者我们的能力达到了，就需要及时去还这些“技术债务”。</span></span></span></span></div><h2 class="se-fd3fc42f" data-slate-type="heading" data-slate-object="block" data-key="1210"><span data-slate-object="text" data-key="1211"><span data-slate-leaf="true" data-offset-key="1211:0" data-first-offset="true"><span data-slate-string="true">课后作业</span></span></span></h2><div class="se-e5f6cafd " data-slate-type="paragraph" data-slate-object="block" data-key="1212"><span data-slate-object="text" data-key="1213"><span data-slate-leaf="true" data-offset-key="1213:0" data-first-offset="true"><span data-slate-string="true">看完我分享的内存优化的方法后，相信你也肯定还有很多好的思路和方法，</span></span></span><span data-slate-object="text" data-key="1214"><span data-slate-leaf="true" data-offset-key="1214:0" data-first-offset="true"><span class="se-7454ed09" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">今天的课后作业是分享一下你的内存优化“必杀技”，在留言区分享一下今天学习、练习的收获与心得</span></span></span></span><span data-slate-object="text" data-key="1215"><span data-slate-leaf="true" data-offset-key="1215:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span></div><div class="se-4815814f " data-slate-type="paragraph" data-slate-object="block" data-key="1216"><span data-slate-object="text" data-key="1217"><span data-slate-leaf="true" data-offset-key="1217:0" data-first-offset="true"><span data-slate-string="true">在文中我提到 Hprof 文件裁剪和重复图片监控，这是很多应用目前都没有做的，而这两个功能也是微信的 APM 框架 Matrix 中内存监控的一部分。Matrix 是我一年多前在微信负责的最后一个项目，也付出了不少心血，最近听说终于准备开源了。</span></span></span></div><div class="se-f5b8fc15 " data-slate-type="paragraph" data-slate-object="block" data-key="1218"><span data-slate-object="text" data-key="1219"><span data-slate-leaf="true" data-offset-key="1219:0" data-first-offset="true"><span data-slate-string="true">那今天我们就先来练练手，尝试使用 HAHA 库快速判断内存中是否存在重复的图片，并且将这些重复图片的 PNG、堆栈等信息输出。最终的实现可以通过向</span></span></span><a data-slate-type="link" data-slate-object="inline" data-key="1220" class="se-de03e9b6 se-555e961b"><span data-slate-object="text" data-key="1221"><span data-slate-leaf="true" data-offset-key="1221:0" data-first-offset="true"><span data-slate-string="true">Sample</span></span></span></a><span data-slate-object="text" data-key="1222"><span data-slate-leaf="true" data-offset-key="1222:0" data-first-offset="true"><span data-slate-string="true">发送 Pull Request。</span></span></span></div><div class="se-e83dcbb0 " data-slate-type="paragraph" data-slate-object="block" data-key="1223"><span data-slate-object="text" data-key="1224"><span data-slate-leaf="true" data-offset-key="1224:0" data-first-offset="true"><span data-slate-string="true">欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“</span></span></span><a data-slate-type="link" data-slate-object="inline" data-key="1225" class="se-de03e9b6 se-555e961b"><span data-slate-object="text" data-key="1226"><span data-slate-leaf="true" data-offset-key="1226:0" data-first-offset="true"><span data-slate-string="true">学习加油礼包</span></span></span></a><span data-slate-object="text" data-key="1227"><span data-slate-leaf="true" data-offset-key="1227:0" data-first-offset="true"><span data-slate-string="true">”，期待与你一起切磋进步哦。</span></span></span></div><div class="se-8fa03f8f" data-slate-type="image" data-slate-object="block" data-key="1228"><img class="se-8ca57d4f" src="https://static001.geekbang.org/resource/image/24/c0/24c190870d71c3daa203a939d67358c0.jpg"></div><div class="se-bd61414d" data-slate-type="image" data-slate-object="block" data-key="1229"><img class="se-91308d5b" src="https://static001.geekbang.org/resource/image/30/aa/306ef8892cc985a19fdd36534e7c5daa.png"></div></div></div> <!----> <!---->